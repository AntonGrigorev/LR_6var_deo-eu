# Отчёт о выполнении ЛР по задаче "Обмен информации между DELO - ЭУ по КР"  


---
## Постановка задачи*

Задача заключается в передачии информации между сервисами DELO - ЭУ об оценке по КР студентов.  

## Известные ограничения и вводные*

По условиям организаторов должна использоваться микросервисная архитектура и шина обмена сообщениями для реализации асинхронной работы сервисов.

### Цели и Предположения Безопасности (ЦПБ)*

#### Цели безопасности*

---

1. Данные не изменяются в ходе передачи и соотвествуют формату:
- №
- Фамилия
- Имя
- Отчество
- Личное дело
- Группа
- Специальность
- Корпоративная почта
- Предмет
- Номер КР
- Баллы за КР
- Статус КР (раньше/позже срока, вовремя)

#### Предположения*

1. Физическая защищённость системы обеспечена

## Архитектура решения*

### Компоненты*


---

| Название | Назначение | Комментарий |
|----|----|----|
|*Cервер Delo* | отвечает за работу Delo | внешний по отношению к системе сервис, имитатор сервера с обновлениями в интернете |
|*Приложение* | сервис с бизнес-логикой | заглушка |
|*Обновление данных* | непосредственно применяет обновление оценок по КР | работает в одном контейнере с *Приложение*, чтобы иметь возможность взаимодействовать с ним |
|*Менеджер* | оркестрирует весь процесс обновления | |
|*Хранилище* | хранит данные для их обработки| |
|*Верификатор* | проверят корректность измненений  | Теоретически, все проверки можно было бы вынести в Updater, но это сделало бы код данной сущности большим и сложным |
|*Монитор безопасности*| авторизует операцию, если она удовлетворяет заданным правилам или блокирует её в противном случае| |
|*Шина Сообщений* | сервис передачи Сообщений от источника получателям |  |
|*Cервер ЭУ* | отвечает за работу ЭУ| |
|*БД* | база данных, с которой происходит обмен данными| |

![HLA](./diagrams/docs/report/hla/hla.png?raw=true "Архитектура")

#### Монитор безопасности (security monitor)

На логическом уровне коммуникация выглядит так

![SM](./diagrams/docs/report/sm/sm.png?raw=true "Монитор безопасности")
Верификатор
Т.е. менеджер обновлений поручает сервису Верификатор проверить, имеет пользователь осуществляющий измененение данных на это право.

### Алгоритм работы решения*

![Sequence diagram](./diagrams/sd.png?raw=true "Диаграмма вызовов")

### Описание cценариев (последовательности выполнения операций), при которых ЦБ нарушаются*

---

Наши вводные, исходя из выбранного охвата задач: после ввода данных по ученику на DELO необходимо обновить данные в ЭУ.

Первая значимая команда в диаграмме – это запрос на проверку и первая возможная проблема, компонент Менеджер  «забыл» отправить запрос на проверку, и таким образом в результате на обновление отправится непроверенные данные.

Следующая значимая команда – запрос на обновление и следующая возможная проблема, это то, что результат проверки может быть проигнорирован и запрос на обновление могут отправиться неверные данные.

Следующая возможная проблема уже не связана командами, но она отражает тот факт, что между тем, как данные проверены и запросом на обновление от Менеджер есть некий зазор по времени. В этот период времени данные обновления могут быть изменены, и на обновление может отправиться неверные данные.

Итого, будем рассматривать следующие три  сценария:

1. «забыли» отправить запрос на проверку обновления;
2. результат проверки проигнорировали;
3. данные обновления изменили после проверки.
  
Ниже представлены три выбранные сценария компрометации целей безопасности на диаграмме процесса обновления:

![Негативные сценарии](./diagrams/sd-negative.png?raw=true "Негативные сценарии")

#### Негативный сценарий 1. Менеджер не проверяет обновление

![Негативный сценарий1](./diagrams/Hacked-manager1.png?raw=true "Менеджер не проверяет обновление")

Результат: недостижение цели безопасности №1: обновление не проверено, возможно повреждение данных или их неверный формат

#### Негативный сценарий 2. Менеджер игнорирует результаты проверки

![Негативный сценарий2](./diagrams/Hacked-manager2.png?raw=true "Менеджер игнорирует результаты проверки")

Результат: недостижение цели безопасности №1: возможно повреждение данных или их неверный формат


#### Негативный сценарий 3. Хранилище подменяет файл после проверки

![Негативный сценарий3](./diagrams/Hacked-manager3.png?raw=true "Storage подменяет файл после проверки")

Результат: недостижение цели безопасности №1: возможна подмена данных

#### Сводная таблица негативных сценариев*

|№  | Название | Скомпрометированная часть системы | Нарушенная цель безопасности |
|----|----|----|----|
|1 | Менеджер не проверяет обновление | Менеджер | 1 |
|2 | Менеджер игнорирует результат проверки | Менеджер | 1 |
|3 | Хранилище подменяет файл после проверки  | Хранилище | 1 |


### Политика архитектуры *


В общем случае, компонент Менеджер может быть недоверенным, результаты проверки могут быть игнорированы или данные могут изменены после проверки.

Так как шина обмена сообщений и монитор безопасности являются общесистемными, они являются доверенными по умолчанию и на диаграмме не отображаются.



![DFD-TCB](./diagrams/architecture-policy.png?raw=true "Доверенные компоненты на диаграмме потоков данных")

#### Обоснование политики архитектуры *

|ЦБ№  | ЦБ | Компонент | Уровень доверия | Обоснование |
|----|----|----|----|----|
| 1 | Данные остаются целыми | Верификатор | доверенный, повышающий целостность данных | этот компонент отвечает за проверку целостности и фиксирование результатов проверки (опечатывание), это критично для ЦБ1
| 1 | Данные остаются целыми | Обновление данных | доверенный, повышающий целостность данных | этот компонент получает запрос от недоверенного менеджера обновлений, поэтому должен осуществлять дополнительный контроль данных, также он не может быть недоверенным, иначе, теоретически, он может обновить сервер произвольными данными |
| | | Менеджер | недоверенный | худшее, что сможет сделать - изменить файл, но это будет обнаружено Верификатор или Обновление данных |
| | | Хранилище | недоверенный | худшее, что сможет сделать - изменить файл, но это будет обнаружено Верификатор или Обновление данных |
| | | Cервер Delo | недоверенный | худшее, что сможет сделать - изменить файл, но это будет обнаружено Верификатор или Обновление данных |

### Политики безопасности*


```python {lineNo:true}

import base64
VERIFIER_SEAL = 'verifier_seal'


def check_operation(id, details):
    authorized = False
    # print(f"[debug] checking policies for event {id}, details: {details}")
    print(f"[info] checking policies for event {id},"
          f" {details['source']}->{details['deliver_to']}: {details['operation']}")
    src = details['source']
    dst = details['deliver_to']
    operation = details['operation']
    if src == 'downloader' and dst == 'manager' \
            and operation == 'download_done':
        authorized = True
    if src == 'manager' and dst == 'downloader' \
            and operation == 'download_file':
        authorized = True
    if src == 'manager' and dst == 'storage' \
            and operation == 'commit_blob':
        authorized = True
    if src == 'manager' and dst == 'verifier' \
            and operation == 'verification_requested':
        authorized = True
    if src == 'verifier' and dst == 'manager' \
            and operation == 'handle_verification_result':
        authorized = True
    if src == 'manager' and dst == 'updater' \
            and operation == 'proceed_with_update' \
            and details['verified'] is True:
        authorized = True
    if src == 'storage' and dst == 'manager' \
            and operation == 'blob_committed':
        authorized = True
    if src == 'storage' and dst == 'verifier' \
            and operation == 'blob_committed':
        authorized = True
    if src == 'verifier' and dst == 'storage' \
            and operation == 'get_blob':
        authorized = True
    if src == 'verifier' and dst == 'storage' \
            and operation == 'commit_sealed_blob' \
            and details['verified'] is True:
        authorized = True
    if src == 'storage' and dst == 'verifier' \
            and operation == 'blob_content':
        authorized = True
    if src == 'updater' and dst == 'storage' \
            and operation == 'get_blob':
        authorized = True
    if src == 'storage' and dst == 'updater' \
            and operation == 'blob_content' and check_payload_seal(details['blob']) is True:
        authorized = True

    return authorized


def check_payload_seal(payload):
    try:
        p = base64.b64decode(payload).decode()
        if p.endswith(VERIFIER_SEAL):
            print('[info] payload seal is valid')
            return True
    except Exception as e:
        print(f'[error] seal check error: {e}')
        return False


```

## Запуск приложения и тестов*

---
**Важно!** Отсутствие 
- понятного описания ручного тестирования приложения 
- автоматических тестов 

для проверки функционала и негативных сценариев приведёт к существенному снижению оценки работы команды.

---

### Запуск приложения*

см. [инструкцию по запуску](../../README.md)

### Запуск тестов*

_Предполагается, что в ходе подготовки рабочего места все системные пакеты были установлены._

Запуск примера: открыть окно терминала в Visual Studio code, в папке secure-update с исходным кодом выполнить 

**make run**
или **docker-compose up -d**

Примечание: сервисам требуется некоторое время для начала обработки входящих сообщений от kafka, поэтому перед переходом к тестам следует сделать паузу 1-2 минуты

запуск тестов:
**make test**
или **pytest**
Ожидаемый результат (окно слева - вывод команды "docker-compose logs -f", окно справа - вывод команды "make test"): 
![pytest report](images/pytest-report.png "Логи сервисов и отчёт pytest")
